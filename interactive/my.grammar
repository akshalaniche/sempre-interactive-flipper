(include dal.grammar)

# Robot action functions
(def @visit visit)
(def @pick pick)
(def @drop drop)

# Color logic functions
(def @dNot descriptionNot)
(def @dOr descriptionOr)
(def @dAnd descriptionAnd)


# Grammar rules

(rule $Action (visit $Field) (lambda x (: @visit (var x))) (anchored 1))
# Visit selected field (usually set by foreach)
(rule $Action (visit) (ConstantFn (: @visit)) (anchored 1))

(rule $Action (pick $Cardinality $Description) (lambda x (lambda y (: @pick (var x) (var y)))) (anchored 1))
(rule $Action (pick $Cardinality) (lambda x (: @pick (var x) (call @dNot (string "")))) (anchored 1))
(rule $Action (drop $Cardinality $Description) (lambda x (lambda y (: @drop (var x) (var y)))) (anchored 1))
(rule $Action (drop $Cardinality) (lambda x (: @drop (var x) (call @dNot (string "")))) (anchored 1))

(rule $Cardinality (single) single (anchored 1))
(rule $Cardinality (all) all (anchored 1))

(rule $Description (has color $Color)
   (IdentityFn) (anchored 1))
(rule $Description ( { $Description } )
   (IdentityFn) (anchored 1))
(rule $Description ($Description &&  $Description)
   (lambda x (lambda y (call @dAnd (var x) (var y)))) (anchored 1))
(rule $Description ($Description ||  $Description)
   (lambda x (lambda y (call @dOr (var x) (var y)))) (anchored 1))
(rule $Description (! $Description)
   (lambda x (call @dNot (var x))) (anchored 1))

(rule $Action (foreach $Set $Action ) (lambda s (lambda a (:foreach (var s) (var a)))) (anchored 1))
(rule $Set (room) (ConstantFn (call getRoom)) (anchored 1))
(rule $Set (world) world (anchored 1))

# Data type definitions

# TODO Find a better way to define these
(for C (red orange yellow blue green purple brown pink)
  (rule $Color (C) (ConstantFn C) (anchored 1)))

(rule $Field ([ $Number , $Number ]) (lambda x (lambda y (call intPair (var x) (var y)))) (anchored 1))
(rule $Set (selected) this (anchored 1))

(rule $Number ($TOKEN) (NumberFn) (anchored 1))
